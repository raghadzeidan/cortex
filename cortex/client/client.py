import time
import math
import sys, socket
import datetime
import logging
import http.client
import requests
import blessings
from .client_utils import Reader


FILE_FORMAT = 'protobuf://'
COMPRESSION_FORMAT = "gzip"
CLIENT_SERVER_PROTOCOL = 'http://'
logging.basicConfig(level = logging.DEBUG,
                    filename = '.client_logs.txt',
                    format = '%(levelname).1s %(asctime)s %(message)s',
                    datefmt = '%Y-%m-%d %H:%M:%S')
term = blessings.Terminal()

def proto_prepare_user_for_takeoff(user):
    '''this functions takes the User struct that has been read and de-serialized by our Reader
    and serializes them in the format that the server is expecting. in this specific case (our project
    case), the format read is identical to the one the server is expecting since I used the same
    protobuf, so all we need to do is Re-serialize the struct before takeoff
    PROJECT_EXPLANATION: lets say, we need to change the reading format from protobuf to STUPID. in this
    case, we need to take the StupidUser() that was generated by the Reader and serialize them
    to the proto format the server is expecting, that way the server goes uninterrupted by future changes'''
    the_user_bytes = user.SerializeToString()
    return the_user_bytes #nothing to do for the serialized bytes, since the server is expecting with the same format

def proto_prepare_snapshot_for_takeoff(snapshot):
    '''this functions serializes the snapshot that was read by the Reader, in a format
    that is appropriate for the server. here we don't do anything since the server is expecitng
    a format that is identical to the one that we read the file from.'''
    the_snapshot_bytes = snapshot.SerializeToString()
    return the_snapshot_bytes #nothing to do for the serialized bytes, since the server is expecting with the same format

def project_client_should_send(available_parsers):
	'''This is a function that defines the context of the client, wether he should
	send data to the server or not, according to the available parsers infromation he received
	from the server (or any other potentional information that might develop in the future)
	for our project purposes, this always returns True cause we're always sending snapshots
	no matter.
	FOR_DEVELOPERS: if things change, wanting clients sending specific params only, this
	function must be implemented. only supports state-less contexts for now'''
	return True

def upload_sample(host, port, path, client_context = project_client_should_send):
	reader_url = f'{FILE_FORMAT}{path}/?compressor={COMPRESSION_FORMAT}'
	reader = Reader(reader_url)
	server_url = f'http://{host}:{port}'
	#Getting available parsers from server
	r = requests.get(server_url + "/config")
	print(term.blue_on_white(str(r)))
	available_parsers = r.reason.split("@") #client receives available parsers seperated by @
	print(term.yellow_on_black(f'Available parsers for client: {available_parsers}'))
	should_takeoff = project_client_should_send(available_parsers)
	if not should_takeoff:
		logging.info('Client did not send snapshots to server. Server configurations not suitable')
		return
	#Hello message to server and receiving biscuit
	the_user_bytes = proto_prepare_user_for_takeoff(reader.user)
	r = requests.post(server_url + "/hello", data = the_user_bytes)
	client_biscuit = r.reason
	print(term.yellow_on_black(f'Client\'s unique biscuit: {client_biscuit}'))
	client_biscuit_snapshot_url = f'{server_url}/{reader.user_id}/{client_biscuit}/snapshot'
	for snapshot in reader:
		print(term.yellow_on_black('Sleeping for 2 seconds before sending next snapshot.'))
		time.sleep(0.2) #TODO check type of sent stuff
		requests.post(client_biscuit_snapshot_url, data = proto_prepare_snapshot_for_takeoff(snapshot))

if __name__ == '__main__':
    argv = sys.argv
    upload_sample(argv[1],argv[2],argv[3])
